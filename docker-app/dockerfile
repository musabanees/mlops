# # base image
# FROM python:3.12-slim

# # workdir
# WORKDIR /app

# #copy
# COPY . /app

# #run
# RUN pip install -r requirements.txt

# #port
# EXPOSE 8080

# # commands
# CMD ["python3", "app.py"]



# 1. Use a small, specific base image
FROM python:3.12-slim

# Set environment variables for best practices
# Prevents Python from writing pyc files to disc
ENV PYTHONDONTWRITEBYTECODE=1
# Prevents Python from buffering stdout and stderr
ENV PYTHONUNBUFFERED=1

# 2. Set the working directory
WORKDIR /app

# 3. Create an unprivileged user to run the application
# This is a critical security best practice
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# Install curl for the HEALTHCHECK command
RUN apt-get update \
    && apt-get install -y curl \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*


# 4. Order commands appropriately to leverage the build cache
# First, copy only the file with dependencies
COPY requirements.txt .

# 5. Cache packages on the host and install dependencies
# This speeds up subsequent builds dramatically
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install --no-cache-dir -r requirements.txt

# 6. Copy the rest of the application code
# Use --chown to give ownership to the new non-root user
COPY --chown=appuser:appgroup . .

# 7. Switch to the unprivileged user
USER appuser

# 8. Expose the port the app runs on
EXPOSE 8080

# 9. Include a HEALTHCHECK for reliability
# This checks if the application is not just running, but healthy
HEALTHCHECK --interval=30s --timeout=5s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:8080/ || exit 1

# 10. Use ENTRYPOINT and CMD for a flexible and robust container
# ENTRYPOINT sets the main executable
ENTRYPOINT ["python3"]
# CMD provides the default argument (your script)
CMD ["app.py"]